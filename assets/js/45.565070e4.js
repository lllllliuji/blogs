(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{469:function(_,v,a){"use strict";a.r(v);var t=a(2),e=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"引言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[_._v("#")]),_._v(" 引言")]),_._v(" "),v("ul",[v("li",[_._v("传统的计算机程序是由软件开发人员根据业务逻辑编写的，业务逻辑明确地规定了每一步该怎么做。")]),_._v(" "),v("li",[_._v("机器学习是从经验中学习的技术，不要求程序员显示地编写具体代码。")])]),_._v(" "),v("h1",{attrs:{id:"_1-机器学习中的关键组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-机器学习中的关键组件"}},[_._v("#")]),_._v(" 1. 机器学习中的关键组件")]),_._v(" "),v("ol",[v("li",[_._v("可以用来学习的数据（data）；")]),_._v(" "),v("li",[_._v("如何转换数据的模型（model）；")]),_._v(" "),v("li",[_._v("一个目标函数（objective function），用来量化模型的有效性；")]),_._v(" "),v("li",[_._v("调整模型参数以优化目标函数的算法（algorithm）。")])]),_._v(" "),v("h2",{attrs:{id:"_1-1-数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-数据"}},[_._v("#")]),_._v(" 1.1 数据")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("数据集")]),_._v("由一个个样本（example，sample）组成，它们遵从独立同分布。")]),_._v(" "),v("li",[v("strong",[_._v("样本")]),_._v("又称为数据点（data point）或数据实例（data instance），通常每个样本由一组称为特征（feature）或协变量（covariance）的属性组成。\n当每个样本的特征类别都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维度（dimensionality）。并不是所有的数据都可以用固定长度的特征向量表示。")]),_._v(" "),v("li",[v("strong",[_._v("标签")]),_._v("（label）是指与输入数据相关联的目标变量或输出值。它是模型学习的关键部分，通常用于监督学习（supervised learning）。")])]),_._v(" "),v("p",[_._v("一般来说，拥有越多数据，可以减少对预先设想假设的依赖，工作就越容易。但是拥有海量的数据是不够的，我们需要正确的数据。数据中的错误、偏见和不充分性会直接影响训练出的模型的质量和表现。")]),_._v(" "),v("h2",{attrs:{id:"_1-2-模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-模型"}},[_._v("#")]),_._v(" 1.2 模型")]),_._v(" "),v("p",[_._v("模型的核心功能是负责将输入数据转换为输出结果，调整参数后的程序称为"),v("em",[_._v("模型")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"_1-3-目标函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-目标函数"}},[_._v("#")]),_._v(" 1.3 目标函数")]),_._v(" "),v("p",[_._v("在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，这被称之为"),v("em",[_._v("目标函数")]),_._v("（objective function）。\n我们通常定义一个目标函数，并希望优化它到最低点。\n因为越低越好，所以这些函数有时被称为"),v("em",[_._v("损失函数")]),_._v("（loss function，或cost function）。"),v("br"),_._v("\n当任务在试图预测数值时，最常见的目标函数是"),v("em",[_._v("平方误差")]),_._v("（squared error），即预测值与实际值之差的平方。在解决分类问题时，最常见的目标函数是"),v("em",[_._v("交叉熵损失")]),_._v("（cross-entropy loss）。通常，损失函数是根据模型参数定义的。")]),_._v(" "),v("h2",{attrs:{id:"_1-4-优化算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-优化算法"}},[_._v("#")]),_._v(" 1.4 优化算法")]),_._v(" "),v("p",[_._v("当我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。\n深度学习中，大多流行的优化算法通常基于一种基本方法--"),v("em",[_._v("梯度下降")]),_._v("（gradient descent），它在可以减少损失的方向上优化参数。")]),_._v(" "),v("h1",{attrs:{id:"_2-各种机器学习问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-各种机器学习问题"}},[_._v("#")]),_._v(" 2. 各种机器学习问题")]),_._v(" "),v("p",[_._v("监督学习、非监督学习和强化学习是机器学习的三种主要类型，各自有不同的特征和应用场景。")]),_._v(" "),v("h2",{attrs:{id:"_2-1-监督学习"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-监督学习"}},[_._v("#")]),_._v(" 2.1 监督学习")]),_._v(" "),v("p",[_._v("每个“特征-标签”对都称为一个"),v("em",[_._v("样本")]),_._v("（example）。"),v("em",[_._v("监督学习")]),_._v("（supervised learning）的目标是生成一个模型，能够将任何输入特征映射到标签（即预测）。")]),_._v(" "),v("p",[_._v("监督学习之所以能发挥作用，是因为在训练参数时，我们为模型提供了一个数据集，其中每个样本都有真实的标签。\n用概率论术语来说，我们希望预测“估计给定输入特征的标签”的条件概率。")]),_._v(" "),v("p",[_._v("监督学习的学习过程一般可以分为三大步骤：")]),_._v(" "),v("ol",[v("li",[_._v("从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；")]),_._v(" "),v("li",[_._v("选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；")]),_._v(" "),v("li",[_._v("将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。")])]),_._v(" "),v("h3",{attrs:{id:"_2-1-1-回归"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-回归"}},[_._v("#")]),_._v(" 2.1.1 回归")]),_._v(" "),v("p",[v("em",[_._v("回归")]),_._v("（regression）是最简单的监督学习任务之一。回归是一种统计分析和机器学习方法，用于建立自变量（输入特征）与因变量（目标输出）之间的关系模型。它主要用于预测"),v("strong",[_._v("连续数值类型的目标变量")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-2-分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-分类"}},[_._v("#")]),_._v(" 2.1.2 分类")]),_._v(" "),v("p",[v("em",[_._v("分类")]),_._v("（classification）是机器学习中的一种任务，其目标是将输入数据分配到预定义的类别或标签中。分类问题通常涉及"),v("strong",[_._v("离散的输出值")]),_._v("，与回归问题（预测连续值）不同。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-3-标记问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-标记问题"}},[_._v("#")]),_._v(" 2.1.3 标记问题")]),_._v(" "),v("p",[_._v("学习预测不相互排斥的类别的问题称为"),v("em",[_._v("多标签分类")]),_._v("（multi-label classification）。举个例子，人们在技术博客上贴的标签，比如“机器学习”“技术”“小工具”“编程语言”“Linux”“云计算”“AWS”。一篇典型的文章可能会用5～10个标签，因为这些概念是相互关联的。关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言”。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-4-搜索"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-搜索"}},[_._v("#")]),_._v(" 2.1.4 搜索")]),_._v(" "),v("p",[_._v("有时，我们不仅仅希望输出一个类别或一个实值。\n在信息检索领域，我们希望对一组项目进行排序。\n以网络搜索为例，目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。\n搜索结果的排序也十分重要，学习算法需要输出有序的元素子集。\n换句话说，如果要求我们输出字母表中的前5个字母，返回“A、B、C、D、E”和“C、A、B、E、D”是不同的。\n即使结果集是相同的，集内的顺序有时却很重要。")]),_._v(" "),v("p",[_._v("该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。"),v("a",{attrs:{href:"https://en.wikipedia.org/wiki/PageRank",target:"_blank",rel:"noopener noreferrer"}},[_._v("PageRank"),v("OutboundLink")],1),_._v("，谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子，但它的奇特之处在于它不依赖于实际的查询。\n在这里，他们依靠一个简单的相关性过滤来识别一组相关条目，然后根据PageRank对包含查询条件的结果进行排序。\n如今，搜索引擎使用机器学习和用户行为模型来获取网页相关性得分，很多学术会议也致力于这一主题。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-5-推荐系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-推荐系统"}},[_._v("#")]),_._v(" 2.1.5 推荐系统")]),_._v(" "),v("p",[_._v("另一类与搜索和排名相关的问题是"),v("em",[_._v("推荐系统")]),_._v("（recommender system），它的目标是向特定用户进行“个性化”推荐。推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率。\n由此，对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。以上只是简单的算法，而工业生产的推荐系统要先进得多，它会将详细的用户活动和项目特征考虑在内。")]),_._v(" "),v("p",[_._v("尽管推荐系统具有巨大的应用价值，但单纯用它作为预测模型仍存在一些缺陷。\n首先，我们的数据只包含“审查后的反馈”：用户更倾向于给他们感觉强烈的事物打分。\n例如，在五分制电影评分中，会有许多五星级和一星级评分，但三星级却明显很少。\n此外，推荐系统有可能形成反馈循环：推荐系统首先会优先推送一个购买量较大（可能被认为更好）的商品，然而目前用户的购买习惯往往是遵循推荐算法，但学习算法并不总是考虑到这一细节，进而更频繁地被推荐。\n综上所述，关于如何处理审查、激励和反馈循环的许多问题，都是重要的开放性研究问题。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-6-序列学习"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-序列学习"}},[_._v("#")]),_._v(" 2.1.6 序列学习")]),_._v(" "),v("p",[_._v("序列学习是一种处理和分析序列数据的机器学习方法。序列数据是指按照时间或其他顺序排列的一系列数据点，常见于文本、时间序列、音频和视频等领域。序列学习的主要目标是从输入序列中提取特征，进行预测、分类或生成新序列。"),v("br"),_._v("\n主要特点：")]),_._v(" "),v("ol",[v("li",[_._v("顺序依赖性：序列学习考虑数据点之间的顺序关系，后一个数据点的输出可能依赖于前一个或多个数据点。")]),_._v(" "),v("li",[_._v("可变长度：输入序列的长度可以不同，模型需要能够处理这种变动性。")])]),_._v(" "),v("p",[_._v("常见类型有标记和解析、自动语音识别、文本到语音和机器翻译。")]),_._v(" "),v("h2",{attrs:{id:"_2-2-无监督学习"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-无监督学习"}},[_._v("#")]),_._v(" 2.2 无监督学习")]),_._v(" "),v("p",[_._v("到目前为止，所有的例子都与监督学习有关，即需要向模型提供巨大数据集：每个样本包含特征和相应标签值。相反，如果工作没有十分具体的目标，就需要“自发”地去学习了。这类数据中不含有“目标”的机器学习问题通常被为"),v("em",[_._v("无监督学习")]),_._v("（unsupervised learning）。")]),_._v(" "),v("p",[_._v("那么无监督学习可以解决的问题：")]),_._v(" "),v("ul",[v("li",[v("em",[_._v("聚类")]),_._v("（clustering）问题：没有标签的情况下，我们是否能给数据分类呢？")]),_._v(" "),v("li",[v("em",[_._v("主成分分析")]),_._v("（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？")]),_._v(" "),v("li",[v("em",[_._v("因果关系")]),_._v("（causality）和"),v("em",[_._v("概率图模型")]),_._v("（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？")]),_._v(" "),v("li",[v("em",[_._v("生成对抗性网络")]),_._v("（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。")])]),_._v(" "),v("h2",{attrs:{id:"_2-3-强化学习"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-强化学习"}},[_._v("#")]),_._v(" 2.3 强化学习")]),_._v(" "),v("p",[_._v("到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。这里所有学习都是在算法与环境断开后进行的，被称为"),v("em",[_._v("离线学习")]),_._v("（offline learning）。强化学习是一种基于代理（agent）与环境（environment）交互的学习方式。代理基于对环境的观察（observation），采取一个动作（action），通过试错（trial and error）来学习最佳策略（policy），以最大化累积的奖励（reward）。")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("强化学习者必须处理"),v("em",[_._v("学分分配")]),_._v("（credit assignment）问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的。")])]),_._v(" "),v("li",[v("p",[_._v("强化学习可能还必须处理部分可观测性问题，也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。")])]),_._v(" "),v("li",[v("p",[_._v("强化学习智能体可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。强化学习智能体必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。")])])]),_._v(" "),v("p",[_._v("一般的强化学习问题是一个非常普遍的问题。\n智能体的动作会影响后续的观察，而奖励只与所选的动作相对应。\n环境可以是完整观察到的，也可以是部分观察到的,解释所有这些复杂性可能会对研究人员要求太高。")]),_._v(" "),v("p",[_._v("当环境可被完全观察到时，强化学习问题被称为"),v("em",[_._v("马尔可夫决策过程")]),_._v("（markov decision process）。\n当状态不依赖于之前的操作时，我们称该问题为"),v("em",[_._v("上下文赌博机")]),_._v("（contextual bandit problem）。\n当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的"),v("em",[_._v("多臂赌博机")]),_._v("（multi-armed bandit problem）。")]),_._v(" "),v("h1",{attrs:{id:"_3-深度学习的发展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-深度学习的发展"}},[_._v("#")]),_._v(" 3. 深度学习的发展")]),_._v(" "),v("p",[_._v("在上个世纪末，随机存取存储器（RAM）非常强大，而计算能力却很弱。\n其次，数据集相对较小。考虑到数据和计算的稀缺性，"),v("em",[_._v("核方法")]),_._v("（kernel method）、"),v("em",[_._v("决策树")]),_._v("（decision tree）和"),v("em",[_._v("图模型")]),_._v("（graph models）等强大的统计工具（在经验上）证明是更为优越的。与神经网络不同的是，这些算法不需要数周的训练，而且有很强的理论依据，可以提供可预测的结果。")]),_._v(" "),v("p",[_._v("大约2010年开始，那些在计算上看起来不可行的神经网络算法变得热门起来，实际上是以下两点导致的：\n其一，随着互联网的公司的出现，为数亿在线用户提供服务，大规模数据集变得触手可及；\n另外，廉价又高质量的传感器、廉价的数据存储（克莱德定律）以及廉价计算（摩尔定律）的普及，特别是GPU的普及，使大规模算力唾手可得。")]),_._v(" "),v("p",[_._v("最近十年，在统计模型、应用和算法方面的进展就像寒武纪大爆发——历史上物种飞速进化的时期。\n事实上，最先进的技术不仅仅是将可用资源应用于几十年前的算法的结果。\n下面列举了帮助研究人员在过去十年中取得巨大进步的想法（虽然只触及了皮毛）。")])])}),[],!1,null,null,null);v.default=e.exports}}]);