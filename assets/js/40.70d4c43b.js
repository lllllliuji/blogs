(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{462:function(e,t,a){"use strict";a.r(t);var o=a(2),r=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"crash-and-recovery-in-database"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#crash-and-recovery-in-database"}},[e._v("#")]),e._v(" Crash and Recovery in Database")]),e._v(" "),t("h2",{attrs:{id:"_1-prerequisites"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-prerequisites"}},[e._v("#")]),e._v(" 1. Prerequisites")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Steal policy")])]),e._v(":  Whether the DBMS allows an uncommitted txn to\noverwrite the most recent committed value of an\nobject in non-volatile storage."),t("br"),e._v(" "),t("strong",[e._v("Steal")]),e._v(": Allowed"),t("br"),e._v(" "),t("strong",[e._v("No-Steal")]),e._v(": Not Allowed")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Force Policy")])]),e._v(": Whether the DBMS requires that all updates made by a txn are reflected on non-volatile storage before the txn can commit."),t("br"),e._v(" "),t("strong",[e._v("Force")]),e._v(": Required"),t("br"),e._v(" "),t("strong",[e._v("No-Force")]),e._v(": Not required")]),e._v(" "),t("h2",{attrs:{id:"_2-no-steal-force-vs-steal-no-force"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-no-steal-force-vs-steal-no-force"}},[e._v("#")]),e._v(" 2. No-Steal + Force VS Steal + No-Force")]),e._v(" "),t("h3",{attrs:{id:"_2-1-no-steal-force"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-no-steal-force"}},[e._v("#")]),e._v(" 2.1 No-Steal + Force")]),e._v(" "),t("p",[e._v("This approach is the easiest to implement:")]),e._v(" "),t("ul",[t("li",[e._v("Never have to undo changes of an aborted txn because the changes were not written to disk")]),e._v(" "),t("li",[e._v("Never have to redo changes of a committed txn because all the changes are guaranteed to be written to disk at commit time (assuming atomic hardware writes).")])]),e._v(" "),t("p",[t("strong",[e._v("Drawbacks")]),e._v(": cannot support write sets that exceed the amount of physical memory available.")]),e._v(" "),t("h3",{attrs:{id:"_2-2-steal-no-force"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-steal-no-force"}},[e._v("#")]),e._v(" 2.2 Steal + No-Force")]),e._v(" "),t("p",[e._v("Almost every DBMS uses NO-FORCE + STEAL(see later)."),t("br"),e._v("\nBest runtime performance but worst recovery performance.")]),e._v(" "),t("h2",{attrs:{id:"_3-shadow-paging"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-shadow-paging"}},[e._v("#")]),e._v(" 3. Shadow Paging")]),e._v(" "),t("p",[e._v("Instead of copying the entire database, the DBMS copies pages on write to create two versions:")]),e._v(" "),t("ul",[t("li",[e._v("Master: Contains only changes from committed txns.")]),e._v(" "),t("li",[e._v("Shadow: Temporary database with changes made from uncommitted txns.\nTo install updates when a txn commits, overwrite the root so it points to the shadow, therebyswapping the master and shadow.")])]),e._v(" "),t("p",[t("strong",[e._v("Buffer Pool Policy")]),e._v(": NO-STEAL + FORCE"),t("br"),e._v(" "),t("strong",[e._v("DrawBacks")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("Copying the entire page table is expensive:\n"),t("ul",[t("li",[e._v("Use a page table structured like a B+tree (LMDB).")]),e._v(" "),t("li",[e._v("No need to copy entire tree, only need to copy paths in the tree that lead to updated leaf nodes.")])])]),e._v(" "),t("li",[e._v("Commit overhead is high:\n"),t("ul",[t("li",[e._v("Flush every updated page, page table, and root.")]),e._v(" "),t("li",[e._v("Data gets fragmented (bad for sequential scans).")]),e._v(" "),t("li",[e._v("Need garbage collection.")]),e._v(" "),t("li",[e._v("Only supports one writer txn at a time or txns in a batch.")])])])]),e._v(" "),t("h2",{attrs:{id:"_4-sqlite-pre-2010"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-sqlite-pre-2010"}},[e._v("#")]),e._v(" 4. Sqlite(pre-2010)")]),e._v(" "),t("p",[e._v('When a txn modifies a page, the DBMS copies the original page to a\nseparate journal file before overwriting master version.Called "rollback mode".'),t("br"),e._v("\nAfter restarting, if a journal file exists, then the DBMS restores it to undo changes from uncommitted txns.")]),e._v(" "),t("h2",{attrs:{id:"_5-write-ahead-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-write-ahead-log"}},[e._v("#")]),e._v(" 5. Write-Ahead Log")]),e._v(" "),t("p",[e._v("Maintain a log file separate from data files that contains the changes that txns make to database.")]),e._v(" "),t("ul",[t("li",[e._v("Assume that the log is on stable storage.")]),e._v(" "),t("li",[e._v("Log contains enough information to perform the necessary undo and redo actions to restore the database."),t("br"),e._v("\nDBMS must write to disk the log file records that correspond to changes made to a database object before it can flush that object to disk.")])]),e._v(" "),t("p",[t("strong",[e._v("Buffer Pool Policy")]),e._v(": STEAL + NO-FORCE")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Protocol")])]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("The DBMS stages all a txn's log records in volatile storage (usually backed by buffer pool).")]),e._v(" "),t("li",[e._v("All log records pertaining to an updated page are written to non-volatile storage before the page itself is over-written in non-volatile storage.")]),e._v(" "),t("li",[e._v("A txn is not considered committed until all its log records have been written to stable storage.")])]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Detail")])]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("Write a $"),t("BEGIN",[e._v("$ record to the log for each txn to mark its starting point.")])],1),e._v(" "),t("li",[e._v("When a txn finishes, the DBMS will:\n"),t("ul",[t("li",[e._v("Write a $"),t("COMMIT",[e._v("$ record on the log")])],1),e._v(" "),t("li",[e._v("Make sure that all log records are flushed before it returns an acknowledgement to application.")])])]),e._v(" "),t("li",[e._v("Each log entry contains information about the change to a single object:\n"),t("ul",[t("li",[e._v("Transaction Id")]),e._v(" "),t("li",[e._v("Object Id")]),e._v(" "),t("li",[e._v("Before Value (UNDO)")]),e._v(" "),t("li",[e._v("After Value (REDO)")])])])]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Implement")])]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("Flushing the log buffer to disk every time a txn commits will become a bottleneck.")]),e._v(" "),t("li",[e._v("The DBMS can use the group commit optimization to batch multiple log flushes together to amortize overhead.\n"),t("ul",[t("li",[e._v("When the buffer is full, flush it to disk.")]),e._v(" "),t("li",[e._v("Or if there is a timeout (e.g., 5 ms).")])])])]),e._v(" "),t("h2",{attrs:{id:"_6-log-scheme"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-log-scheme"}},[e._v("#")]),e._v(" 6. Log Scheme")]),e._v(" "),t("p",[t("strong",[e._v("Physical Logging")])]),e._v(" "),t("ul",[t("li",[e._v("Record the byte-level changes made to a specific page.")]),e._v(" "),t("li",[e._v("Example: git diff")])]),e._v(" "),t("p",[t("strong",[e._v("Logical Logging")])]),e._v(" "),t("ul",[t("li",[e._v("Record the high-level operations executed by txns.")]),e._v(" "),t("li",[e._v("Example: UPDATE, DELETE, and INSERT queries.")])]),e._v(" "),t("p",[t("strong",[e._v("Physiological Logging")])]),e._v(" "),t("ul",[t("li",[e._v("Hybrid approach with byte-level changes for a single tuple identified by page id + slot number.")]),e._v(" "),t("li",[e._v("Does not specify organization of the page.")])]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Physical VS Logical Logging")])])]),e._v(" "),t("ul",[t("li",[e._v("Logical logging requires less data written in each log record than physical logging.")]),e._v(" "),t("li",[e._v("Difficult to implement recovery with logical logging if you have concurrent txns running at lower isolation levels.\n"),t("ul",[t("li",[e._v("Hard to determine which parts of the database may have been modified by a query before crash.")]),e._v(" "),t("li",[e._v("Also takes longer to recover because you must re-execute\nevery txn all over again.")])])])]),e._v(" "),t("h2",{attrs:{id:"_7-log-structured-systems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-log-structured-systems"}},[e._v("#")]),e._v(" 7. Log-Structured Systems")]),e._v(" "),t("p",[e._v("Log-structured DBMSs do not have dirty pages.")]),e._v(" "),t("ul",[t("li",[e._v("Any page retrieved from disk is immutable.")])]),e._v(" "),t("p",[e._v("The DBMS buffers log records in in-memory\npages (MemTable). If this buffer is full, it must be flushed to disk. But it may contain changes uncommitted txns.")]),e._v(" "),t("p",[e._v("These DBMSs still maintain a separate WAL to\nrecreate the MemTable on crash.")]),e._v(" "),t("h2",{attrs:{id:"_8-checkpoint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-checkpoint"}},[e._v("#")]),e._v(" 8. Checkpoint")]),e._v(" "),t("p",[e._v("The WAL will grow forever."),t("br"),e._v("\nAfter a crash, the DBMS must replay the entire log, which will take a long time."),t("br"),e._v("\nThe DBMS periodically takes a checkpoint where it flushes all buffers out to disk.")]),e._v(" "),t("ul",[t("li",[e._v("This provides a hint on how far back it needs to replay\nthe WAL after a crash.")])]),e._v(" "),t("p",[t("em",[t("strong",[e._v("Protocal")])]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("Pause all queries.")]),e._v(" "),t("li",[e._v("Flush all WAL records in memory to disk.")]),e._v(" "),t("li",[e._v("Flush all modified pages in the buffer pool to disk.")]),e._v(" "),t("li",[e._v("Write a "),t("CHECKPOINT",[e._v(" entry to WAL and flush to disk.")])],1),e._v(" "),t("li",[e._v("Resume queries.")])]),e._v(" "),t("p",[t("strong",[e._v("Recovery")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("In the redo phase, the system replays updates of all transactions by scanning the log forward from the last checkpoint.\n"),t("ul",[t("li",[e._v("The list of transactions to be rolled back, undo-list, is initially set to the list L in the $<checkpoint \\ L>$ log record.")]),e._v(" "),t("li",[e._v("Whenever a normal log record of the form $<T_i, X_j, V_1, V_2>$, or a redo-only log record of the form $<T_i, X_j, V_2>$ is encountered, the operation is redone; that is, the value $V_2$ is written to data item $X_j$.")]),e._v(" "),t("li",[e._v("Whenever a log record of the form $<T_i \\ start>$ is found, $T_i$ is added to undo-list.")]),e._v(" "),t("li",[e._v("Whenever a log record of the form $<T_i \\ abort>$ or $<T_i \\ commit>$ is found, $T_i$ is removed from undo-list.")])])]),e._v(" "),t("li",[e._v("In the undo phase, the system rolls back all transactions in the undo-list. It performs rollback by scanning the log backward from the end.\n"),t("ul",[t("li",[e._v("Whenever it finds a log record belonging to a transaction in the undo-list, it performs undo actions just as if the log record had been found during the rollback of a failed transaction.")]),e._v(" "),t("li",[e._v("When the system finds a $<T_i \\ start>$ log record for a transaction $T_i$ in undolist, it writes a $<T_i \\ abort>$ log record to the log and removes $T_i$ from undolist.")]),e._v(" "),t("li",[e._v("The undo phase terminates once undo-list becomes empty, that is, the system has found $<T_i \\ start>$ log records for all transactions that were initially in undo-list.")])])])]),e._v(" "),t("p",[e._v("After the undo phase of recovery terminates, normal transaction processing can resume.")]),e._v(" "),t("p",[t("strong",[e._v("DrawBacks")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("requires that all updates to the database be temporarily suspended while the checkpoint is in progress.")]),e._v(" "),t("li",[e._v("the DBMS must stall txns when it takes a checkpoint to ensure a consistent snapshot.")]),e._v(" "),t("li",[e._v("Scanning the log to find uncommitted txns can take a long time.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);