(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{487:function(e,s,t){"use strict";t.r(s);var n=t(2),a=Object(n.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("hot key  bottleneck db"),s("br"),e._v("\nmemcache doesn't need to know the existence of DB, cache some computed result for next read.\nif you don't do something clever, data stored in the memcache will get out of sync with the data in the database."),s("br"),e._v("\ndo not cache data indefinitely!"),s("br"),e._v("\nThe other situation in which they need to provide consistency is if a user updates their own data and reads that same data that the human knows that they just updated, it's extremely confusing for the user to see stale data.(front end delete, Mcsqueal do delete like canal)"),s("br"),e._v("\nhow do they keep mc content consistent w/ DB content?")]),e._v(" "),s("ol",[s("li",[e._v("DBs send invalidates (delete()s) to all mc servers that might cache\nthis is McSqueal in Figure 6")]),e._v(" "),s("li",[e._v("writing client also invalidates mc in local cluster\nfor read-your-own-writes\nthey ran into a number of DB-vs-mc consistency problems\ndue to races when multiple clients read from DB and put() into mc\nor: there is not a single path along which updates flow in order")])]),e._v(" "),s("p",[e._v("what were the races and fixes?")]),e._v(" "),s("p",[e._v("Race 1:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  k not in cache  \n  C1 get(k), misses  \n  C1 v1 = read k from DB  \n    C2 writes k = v2 in DB  \n    C2 delete(k)  \n  C1 set(k, v1)  \n  now mc has stale data, delete(k) has already happened\n  will stay stale indefinitely, until k is next written\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[s("strong",[e._v("solved with leases")]),e._v(" -- C1 gets a lease from mc, C2's delete() invalidates lease,\nso mc ignores C1's set\nkey still missing, so next reader will refresh it from DB")]),e._v(" "),s("p",[e._v("Race 2:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  during cold cluster warm-up\n  remember: on miss, clients try get() in warm cluster, copy to cold cluster\n  k starts with value v1\n  C1 updates k to v2 in DB\n  C1 delete(k) -- in cold cluster\n  C2 get(k), miss -- in cold cluster\n  C2 v1 = get(k) from warm cluster, hits\n  C2 set(k, v1) into cold cluster\n  now mc has stale v1, but delete() has already happened\n    will stay stale indefinitely, until key is next written\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[s("strong",[e._v("solved with two-second hold-off")]),e._v(", just used on cold clusters\nafter C1 delete(), cold mc ignores set()s for two seconds\nby then, delete() will (probably) propagate via DB to warm cluster")]),e._v(" "),s("p",[e._v("Race 3:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  k starts with value v1\n  C1 is in a secondary region\n  C1 updates k=v2 in primary DB\n  C1 delete(k) -- local region\n  C1 get(k), miss\n  C1 read local DB  -- sees v1, not v2!\n  later, v2 arrives from primary DB\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[s("strong",[e._v('solved by "remote mark"')]),e._v('\nC1 delete() marks key "remote"\nget() miss yields "remote"\ntells C1 to read from '),s("em",[e._v("primary")]),e._v(' region\n"remote" cleared when new data arrives from primary region')]),e._v(" "),s("p",[e._v("Q: aren't all these problems caused by clients copying DB data to mc?\nwhy not instead have DB send new values to mc, so clients only read mc?\nthen there would be no racing client updates &c, just ordered writes\nA:")]),e._v(" "),s("ol",[s("li",[e._v("DB doesn't generally know how to compute values for mc\ngenerally client app code computes them from DB results,\ni.e. mc content is often not simply a literal DB record")]),e._v(" "),s("li",[e._v("would increase read-your-own writes delay")]),e._v(" "),s("li",[e._v("DB doesn't know what's cached, would end up sending lots\nof values for keys that aren't cached")])])])}),[],!1,null,null,null);s.default=a.exports}}]);